#!/usr/bin/env python3
"""
QuietWire Ledger â€” INDEX builder
Scans canonized/ (and intake/) for Markdown entries, reads YAML-ish frontmatter,
and generates a sorted INDEX.md (grouped by ledger_stream). No external deps.
"""
import re, sys, hashlib
from pathlib import Path
from datetime import datetime

RE_FRONT = re.compile(r"^---\s*\n(.*?)\n---\s*\n", re.DOTALL)

def parse_frontmatter(txt: str) -> dict:
    m = RE_FRONT.match(txt)
    if not m: return {}
    lines = m.group(1).splitlines()
    data = {}
    stack = [data]; indents = [0]
    def setv(d,k,v): d[k]=v
    for ln in lines:
        if not ln.strip(): continue
        pad = len(ln)-len(ln.lstrip())
        while pad < indents[-1]:
            stack.pop(); indents.pop()
        if ln.lstrip().startswith("- "):
            item = ln.strip()[2:].strip().strip('"').strip("'")
            if stack[-1]:
                last_key = list(stack[-1].keys())[-1]
                if not isinstance(stack[-1][last_key], list): stack[-1][last_key]=[]
                stack[-1][last_key].append(item)
            else:
                stack[-1]["_list_"] = stack[-1].get("_list_", []) + [item]
            continue
        if ":" in ln:
            k,v = ln.split(":",1); k=k.strip(); v=v.strip()
            if v == "":
                newd = {}; setv(stack[-1], k, newd); stack.append(newd); indents.append(pad+2)
            else:
                v = v.strip('"').strip("'")
                if v.lower() in ("true","false"): v=(v.lower()=="true")
                elif v.lower() in ("null","none"): v=None
                setv(stack[-1], k, v)
    return data

def sha256_path(p: Path) -> str:
    h = hashlib.sha256()
    with p.open("rb") as f:
        for ch in iter(lambda: f.read(65536), b""): h.update(ch)
    return h.hexdigest()

def collect_entries(repo_root: Path):
    entries=[]
    for glob in ("canonized/**/*.md","intake/**/*.md"):
        for p in repo_root.glob(glob):
            if p.is_dir(): continue
            if p.name.lower()=="readme.md": continue
            txt = p.read_text(encoding="utf-8", errors="ignore")
            fm  = parse_frontmatter(txt)
            ts  = fm.get("created_at") or fm.get("timestamp") or ""
            try: sortkey = datetime.fromisoformat(ts.replace("Z","+00:00")) if ts else datetime.min
            except: sortkey = datetime.min
            entries.append({
                "path": str(p.relative_to(repo_root)),
                "title": fm.get("title") or p.stem,
                "ledger_id": fm.get("ledger_id") or "",
                "status": fm.get("canonical_status") or "",
                "stream": fm.get("ledger_stream") or "Uncategorized",
                "created_at": ts,
                "domain": fm.get("semantic_domain") or "",
                "sha": sha256_path(p),
                "_k": sortkey
            })
    entries.sort(key=lambda e: e["_k"], reverse=True)
    return entries

def render(entries):
    L=["# ðŸ“š QuietWire Ledger â€” Canonical Index","","> Auto-generated by `tools/build_index.py`. Do not edit manually."]
    if not entries:
        L+=["", "_No canonized entries found yet. Commit entries under `canonized/` with YAML frontmatter to populate this index._"]
        return "\n".join(L)
    by={}
    for e in entries: by.setdefault(e["stream"], []).append(e)
    for stream, items in sorted(by.items(), key=lambda kv: kv[0].lower()):
        L.append(f"\n## Stream: `{stream}`\n")
        L+=["| Title | Ledger ID | Status | Created | Domain | Path | SHA256 |",
            "|---|---|---|---|---|---|---|"]
        for e in items:
            L.append(f"| {e['title']} | {e['ledger_id']} | {e['status']} | {e['created_at']} | {e['domain']} | `{e['path']}` | `{e['sha'][:12]}â€¦` |")
    return "\n".join(L)

def main():
    repo = Path(sys.argv[1]) if len(sys.argv)>1 else Path(".")
    out  = Path(sys.argv[2]) if len(sys.argv)>2 else Path("INDEX.md")
    out.write_text(render(collect_entries(repo)), encoding="utf-8")
    print(f"INDEX written to {out}")

if __name__=="__main__": main()